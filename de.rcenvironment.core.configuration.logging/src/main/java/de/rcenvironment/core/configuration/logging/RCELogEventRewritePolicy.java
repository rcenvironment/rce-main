/*
 * Copyright 2024 DLR, Germany
 * 
 * SPDX-License-Identifier: EPL-1.0
 * 
 * https://rcenvironment.de/
 */

package de.rcenvironment.core.configuration.logging;

import org.apache.logging.log4j.Level;
import org.apache.logging.log4j.core.Core;
import org.apache.logging.log4j.core.LogEvent;
import org.apache.logging.log4j.core.appender.rewrite.RewritePolicy;
import org.apache.logging.log4j.core.config.plugins.Plugin;
import org.apache.logging.log4j.core.config.plugins.PluginFactory;
import org.apache.logging.log4j.core.impl.Log4jLogEvent;
import org.apache.logging.log4j.message.FormattedMessage;
import org.apache.logging.log4j.message.Message;

/**
 * A custom log event filtering and rewriting policy for RCE. We primarily use this to mask irrelevant log events generated by libraries and
 * framework parts that can not be masked by simple package or class level rules.
 * 
 * Note that while such filtering rules MAY be used to suppress irrelevant warnings, or in unusual cases even errors, this is only
 * acceptable for root causes that cannot be fixed with reasonable effort instead AND that are estimated to cause no actual follow-up
 * problems. Such filtering rules MUST also be explained by commenting them in the filtering code below.
 * 
 * As logging is a relatively high-volume process, special care should be taken to implement all filtering rules as efficiently as possible.
 * 
 * @author Robert Mischke
 */
@Plugin(name = "RCELogEventRewritePolicy", elementType = "rewritePolicy", category = Core.CATEGORY_NAME)
public class RCELogEventRewritePolicy implements RewritePolicy {

    @PluginFactory
    public static RCELogEventRewritePolicy createInstance() {
        return new RCELogEventRewritePolicy();
    }

    @Override
    public LogEvent rewrite(LogEvent event) {

        // readability alias
        final Level originalLevel = event.getLevel();
        // when writing filters, prefer to only check the format string ("template" here) for efficiency
        final String messageTemplate = event.getMessage().getFormat();

        // rule for MANTIS-18211: eliminate highly verbose Felix SCR log output, about 4.000 lines per run;
        // we have not found a way to actually disable the generation of these messages
        // TODO review/retest after the next RCP upgrade
        if (originalLevel == Level.DEBUG && messageTemplate.startsWith("bundle org.apache.felix.scr:")) {
            return suppressMessage(event);
        }

        // all following filters only affect warnings, so exit immediately for anything else
        if (originalLevel != Level.WARN) {
            return event;
        }

        if (messageTemplate == null) {
            // unlikely, but make sure we do not cause NPEs within this filter
            return event;
        }

        // rule for MANTIS-17266; this is a library warning which occurs fairly often, but with no clear path to prevent it
        if (messageTemplate.endsWith("stream is already closed")) {
            return reduceLogLevelWithMessagePrefix(event, Level.DEBUG);
        }

        // return the unmodified event if no filter matched
        return event;
    }

    private Log4jLogEvent suppressMessage(LogEvent event) {
        // the log4j documentation states that returning "null" should work, but this actually causes problems,
        // so we reduce the level and let the default DEBUG level filter eliminate the event instead
        return reduceLogLevel(event, Level.TRACE);
    }

    private Log4jLogEvent reduceLogLevel(LogEvent event, Level newLevel) {
        return new Log4jLogEvent.Builder(event).setLevel(newLevel).build();
    }

    private Log4jLogEvent reduceLogLevelWithMessagePrefix(LogEvent event, Level newLevel) {
        final Message originalMessage = event.getMessage();
        final Message substituteMessage =
            new FormattedMessage(String.format("[Log level reduced from %s] %s",
                event.getLevel().name(), originalMessage.getFormat()), originalMessage.getParameters());
        return new Log4jLogEvent.Builder(event).setMessage(substituteMessage).setLevel(newLevel).build();
    }

}
