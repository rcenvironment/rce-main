/*
 * Copyright 2024 DLR, Germany
 * 
 * SPDX-License-Identifier: EPL-1.0
 * 
 * https://rcenvironment.de/
 */

package de.rcenvironment.core.configuration.logging;

import org.apache.logging.log4j.Level;
import org.apache.logging.log4j.core.Core;
import org.apache.logging.log4j.core.LogEvent;
import org.apache.logging.log4j.core.appender.rewrite.RewritePolicy;
import org.apache.logging.log4j.core.config.plugins.Plugin;
import org.apache.logging.log4j.core.config.plugins.PluginFactory;
import org.apache.logging.log4j.core.impl.Log4jLogEvent;
import org.apache.logging.log4j.message.FormattedMessage;
import org.apache.logging.log4j.message.Message;

/**
 * A custom log event filtering and rewriting policy for RCE. We primarily use this to mask irrelevant log events generated by libraries and
 * framework parts that can not be masked by simple package or class level rules.
 * 
 * Note that while such filtering rules MAY be used to suppress irrelevant warnings, or in unusual cases even errors, this is only
 * acceptable for root causes that cannot be fixed with reasonable effort instead AND that are estimated to cause no actual follow-up
 * problems. Such filtering rules MUST also be explained by commenting them in the filtering code below.
 * 
 * As logging is a relatively high-volume process, special care should be taken to implement all filtering rules as efficiently as possible.
 * 
 * @author Robert Mischke
 */
@Plugin(name = "RCELogEventRewritePolicy", elementType = "rewritePolicy", category = Core.CATEGORY_NAME)
public class RCELogEventRewritePolicy implements RewritePolicy {

    @PluginFactory
    public static RCELogEventRewritePolicy createInstance() {
        return new RCELogEventRewritePolicy();
    }

    @Override
    public LogEvent rewrite(LogEvent event) {

        // all current filtering use cases only affect warnings, so exit immediately for anything else
        if (event.getLevel() != Level.WARN) {
            return event;
        }

        // if possible, apply the filter selection without actually rendering the message for efficiency
        String messageTemplate = event.getMessage().getFormat();

        // TODO example rule; apply actual filtering rules here
        if ("dummy".equals(messageTemplate)) {
            return reduceLogLevelToDebug(event);
        }

        // return the unmodified event if no filter matched
        return event;
    }

    private Log4jLogEvent reduceLogLevelToDebug(LogEvent event) {
        final Message originalMessage = event.getMessage();
        final Message substituteMessage =
            new FormattedMessage(String.format("[Log level reduced from %s] %s",
                event.getLevel().name(), originalMessage.getFormat()), originalMessage.getParameters());
        return new Log4jLogEvent.Builder(event).setMessage(substituteMessage).setLevel(Level.DEBUG).build();
    }

}
